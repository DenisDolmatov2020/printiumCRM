import{n as O,r as b,s as A,q as E,u as R,v as k,h as M,x as U,y as z,z as x,m as N,A as j,B as F,C as D,o as C,c as w,b as i,a as g,w as _,d as m,F as V,D as q,t as P}from"./entry.Tqj8lCA3.js";import{u as I}from"./useAuthUser.z1Xl-Uq0.js";const S=o=>o==="defer"||o===!1;function K(...o){var T;const c=typeof o[o.length-1]=="string"?o.pop():void 0;typeof o[0]!="string"&&o.unshift(c);let[a,u,e={}]=o;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof u!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=U(),B=()=>null,v=()=>t.isHydrating?t.payload.data[a]:t.static.data[a];e.server=e.server??!0,e.default=e.default??B,e.getCachedData=e.getCachedData??v,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??O.deep,e.dedupe=e.dedupe??"cancel";const h=()=>![null,void 0].includes(e.getCachedData(a));if(!t._asyncData[a]||!e.immediate){(T=t.payload._errors)[a]??(T[a]=null);const r=e.deep?b:A;t._asyncData[a]={data:r(e.getCachedData(a)??e.default()),pending:b(!h()),error:E(t.payload._errors,a),status:b("idle")}}const s={...t._asyncData[a]};s.refresh=s.execute=(r={})=>{if(t._asyncDataPromises[a]){if(S(r.dedupe??e.dedupe))return t._asyncDataPromises[a];t._asyncDataPromises[a].cancelled=!0}if((r._initial||t.isHydrating&&r._initial!==!1)&&h())return Promise.resolve(e.getCachedData(a));s.pending.value=!0,s.status.value="pending";const p=new Promise((n,l)=>{try{n(u(t))}catch(H){l(H)}}).then(n=>{if(p.cancelled)return t._asyncDataPromises[a];let l=n;e.transform&&(l=e.transform(n)),e.pick&&(l=L(l,e.pick)),t.payload.data[a]=l,s.data.value=l,s.error.value=null,s.status.value="success"}).catch(n=>{if(p.cancelled)return t._asyncDataPromises[a];s.error.value=z(n),s.data.value=x(e.default()),s.status.value="error"}).finally(()=>{p.cancelled||(s.pending.value=!1,delete t._asyncDataPromises[a])});return t._asyncDataPromises[a]=p,t._asyncDataPromises[a]};const f=()=>s.refresh({_initial:!0}),y=e.server!==!1&&t.payload.serverRendered;{const r=N();if(r&&!r._nuxtOnBeforeMountCbs){r._nuxtOnBeforeMountCbs=[];const n=r._nuxtOnBeforeMountCbs;r&&(R(()=>{n.forEach(l=>{l()}),n.splice(0,n.length)}),k(()=>n.splice(0,n.length)))}y&&t.isHydrating&&(s.error.value||h())?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):r&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?r._nuxtOnBeforeMountCbs.push(f):e.immediate&&f(),e.watch&&M(e.watch,()=>s.refresh());const p=t.hook("app:data:refresh",async n=>{(!n||n.includes(a))&&await s.refresh()});r&&k(p)}const d=Promise.resolve(t._asyncDataPromises[a]).then(()=>s);return Object.assign(d,s),d}function L(o,c){const a={};for(const u of c)a[u]=o[u];return a}function $(o){return{}}const G={class:"mb-3 text-light-100"},J={class:"table w-full"},Q={class:"table-header-group font-bold"},W={class:"table-row"},X={class:"table-row-group"},ee=j({__name:"admin",async setup(o){let c,a;const{data:u}=([c,a]=F(()=>K("users",()=>$fetch("/api/users",{headers:$()}))),c=await c,a(),c),e=I();return(t,B)=>{const v=D("PageTitle"),h=D("PageDescription"),s=D("PageUser"),f=D("TableHeaderCell"),y=D("TableBodyCell");return C(),w("div",null,[i(v,{title:"Admin page"}),i(h,{description:"This page should only be visible if user is connected and has admin role"}),i(s,{user:x(e)},null,8,["user"]),g("div",G,[g("div",J,[g("div",Q,[g("div",W,[i(f,null,{default:_(()=>[m("ID")]),_:1}),i(f,null,{default:_(()=>[m("Email")]),_:1}),i(f,null,{default:_(()=>[m("Roles")]),_:1})])]),g("div",X,[(C(!0),w(V,null,q(x(u),d=>(C(),w("div",{key:d.id,class:"table-row"},[i(y,null,{default:_(()=>[m(P(d.id),1)]),_:2},1024),i(y,null,{default:_(()=>[m(P(d.email),1)]),_:2},1024),i(y,null,{default:_(()=>[m(P(d.roles.join(", ")),1)]),_:2},1024)]))),128))])])])])}}});export{ee as default};
